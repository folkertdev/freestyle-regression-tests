import os
import subprocess

import concurrent.futures
from functools import namedtuple

from config import exe_old, exe_new, output_old, output_new, file, output_result

# start and end frame (both inclusive)
start, end = (65, 65)

# utility function
percentage = lambda old, new: round((old / new - 1) * 100, 4)

def run_render(args):
    """ Runs `args`, logs results (also handles errors) """
    Frame = namedtuple("Frame", ["name", "time"])
    with subprocess.Popen(" ".join(args), stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as p:
        output = list()
        it = iter(p.stdout.readline, b'')
        for line in it:
            # unique line produced by the style module. it contains the information we need
            if line.startswith(b"regtest"):
                name, time = line.split()[-2:]
                output.append(Frame(str(name, 'utf-8'), round(float(time), 5)))
            # an error has occured in executing the style module: log the error and stop the process
            if line.startswith(b"Error ex"):
                for line in it:
                    # Fra* lines are irrelevant, so skip them
                    if not line.startswith(b"Fra"):
                        print(str(line, 'utf-8').strip("\r\n"))
                    # the information after this line is not relevant, so stop here
                    if line.startswith(b"location"):
                        raise RuntimeError("Error in style module")
        return output

def check_regressions(path_old, path_new, path_output, names):
    """Checks render results from the current run for regressions (with ImageMagick)"""
    # lists the files generated by the current render
    files_to_check = ("{:04d}.png".format(i) for i in range(start, end + 1))
    # formats those into paths 
    commands = ((path_old + filename, path_new + filename, path_output + "/" + name + '.png') for filename, name in zip(files_to_check, names))
    # (try to) run these concurrently
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for result in executor.map(run_comparison, commands):
            # handeling of the result is done in `run_comparison`.
            pass 


def run_comparison(args):
    """ Runs ImageMagick, logs results """
    old, new, output = args
    cmd = ("compare -metric MAE {} {} {}".format(old, new, output))
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    for line in p.stdout.readlines():
        if not line.startswith(b"0"):
            print(output, " has regressions!")
            break
    else:
        # deletes the images
        os.remove(output)
        os.remove(new)
        os.remove(old)
        # log here if you want to know all went well
        pass 


def main():
    # namedtuple for storing the results (generally using named tuples is a good practice and it's handy here)
    Result = namedtuple("Result", ["name", "old", "new", "perc"])
    # commands we'll execute. formatting them this way is preferable for some types of execution
    old = (exe_old, file, "-b", "-o", output_old, "-F", "PNG", "-s", str(start), "-e", str(end), "-a")
    new = (exe_new, file, "-b", "-o", output_new, "-F", "PNG", "-s", str(start), "-e", str(end), "-a")
    # process the results
    results = list()
    for (name, time_old), (_, time_new) in zip(run_render(old), run_render(new)):
        result = Result(name, time_old, time_new, percentage(time_old, time_new))
        print("{0.name:54} {0.perc:8.2f}%  {0.old:10.4f}s {0.new:5.4f}s".format(result))
        results.append(result)
    # print some generall statistics (total process time, )
    names, times_old, times_new, _ = zip(*results)
    old, new = sum(times_old), sum(times_new)
    print("old: {:5.3f}s, new {:5.3f}s, delta {:5.3f}s, perc {:5.2f}%".format(old, new, old - new, percentage(old,new)))
    check_regressions(output_old, output_new, output_result, names)


if __name__ == '__main__':
    main()
    







